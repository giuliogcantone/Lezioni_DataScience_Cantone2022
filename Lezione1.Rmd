---
title: "Formati e strutture dati elementari su R"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
pacman::p_load("tidyverse")
```

# Formati e Documenti

Con la parola "Formati" ci riferiamo alla estensione (es, `.txt`) dei documenti (files) con cui lavoriamo. Questo può creare un po' di confusione col concetto di "formato tabellare", che di fatto è una "struttura dati" comune a più formati informatici nella Data Science.

Ci sono due formati di files comunemente usati su R.

## Lo Script

Per aprire un nuovo "Script". In alto a sinistra, andate su "Files", poi su "New Files", ed infine "R Script". Potete anche premere `CTRL + Shift + N`.

Lo script altro non è che un file di testo in cui annotate i comandi per lanciarli uno per uno, oppure in sequenza.

Per lanciare un comando dentro uno script bisogna posizionare il cursore del testo all'inizio del comando e poi premere `Invio + ctrl`. Premere Invio da solo manda a capo il testo.

Provate a scrivere questo comando in uno script:

```
print("Ciao a tutti, come va?")
```

e poi lanciatelo con `Invio + ctrl`.

---
`print` è un comando che ordina a R di trasportare **il risultato** di una certa operazione in console. Per esempio, `2+2` è una operazione di somma. Che succede se si lancia `print(2+2)`?

R è ottimizzato in maniera tale che moltissimi comandi hanno un "print" implicito del loro risultato in console. Per esempio, se scrivete solo `2+2` in uno script e lo lanciate, cosa vedete apparire in console?

Questo perchè R *interpreta* il vostro comando, non esegue sempre e solo ciecamente gli ordini.

---

Adesso lanciate `print("2+2")`. Cosa è cambiato?
In questa lezione impareremo a disambiguare le operazioni per ottenere sempre il risultato desiderato.

---

Generalmente, non vorrete mai lanciare uno script per intero.

---
Questo non è Python! Su Python c'è la (brutta) tendenza a lanciare gli script per intero. Questa pratica non aiuta affatto chi è alle prime armi perché non permette di individuare quale pezzetto del codice è sbagliato.
---

## Il Markdown

Il Markdown è un formato che interpreta un codice testuale testo e lo traduce in HTML, così da renderlo pubblicabile come pagina online.

Per esempio, queste lezioni sono scritte in R Markdown, che è una versione alternativa di Markdwon che permette di eseguire blocchi di codice ("chunks") in R, Python ed altri linguaggi.

Per aprire un nuovo file Markdown, seguite la stessa procedura per aprire uno Script, ma stavolta scegliete R Markdown.

Il Markdown è simile allo script, ma in alto a destra c'è un simbolo con un più ed una "c". Se premuto, apre un chunk del linguaggio scelto. Adesso si può scrivere un codice, ad esempio una sequenza di comandi. In alto a destra del chunk c'è una freccia verso destra. Premendo la freccia, il codice sarà eseguito, ma piuttosto che riportare i risultati in console, li riporterà immediatamente sotto il chunk.

```{r include=TRUE}
print("ciao, come state?")
"tutto bene"
```


---
Questo modo di visualizzare i risultati dei comandi è molto simile al metodo di programmazione per Jupyter Notebook, che è molto popolare tra chi programma in Python.
---

## Progetti

Una buona pratica è creare dei Progetti di R. Queste sono cartelle del vostro computer che sono già auto-organizzate in maniera efficiente, cosicchè se un documento R (Script, Markdown, etc.) salverà un risultato su un file esterno, questo file esterno si troverà comunque nella cartella del Progetto.

Il Progetto si apre da File -> New Project.
Da qui dovreste anche potervi connettere a progetti "condivisi" su piattaforme come Github.

# Strutture elementari

## Assegnazione in memoria di un valore ad un oggetto nel Global Environment (Workplace)

Un valore è una entità simbolica interpretabile da R secondo uno schema di riferimento tipico.
I tre valori più comuni sono:

- valore logico (**logical**), detto altresì valore binario. Rappresenta uno stato di verità (**TRUE**, oppure la singola lettera T) oppure di falsità (**FALSE**, oppure F). 
- numeri, divisi tra numeri interi (**integer**) e numeri con la virgola (**double**)
- stringhe (**character**), cioé simboli alfanumerici compresi tra `" "` oppure `' '`. Questi simboli tendono a formare parole, sigle o frasi (**character**)

Altri valori "complessi" possono essere:

- Le date
- I livelli delle variabili ordinali (**factor**)

## Assegnazioni, Interrogazioni ed Invocazioni (Chiamate)

La assegnazione è un comando speciale con cui si stabilisce una relazione per cui un valore o una struttura (per esempio, una tabella) viene assegnato ad una parola (stavolta senza virgolette).

Il comando dell'Assegnazione è `->` (oppure, `->`).

Per esempio, se voglio assegnare il valore della somma `2+2` alla parola `quattro`, comanderò:

`2+2 -> quattro`

oppure

`quattro <- 2+2`

Però spesso R *interpreta* anche `=` come un comando di assegnazione. Spesso la grammatica corretta dipende dal dialetto che stiamo usando, e solo la pratica ci farà capire il simbolo più appropriato.

```{r}
1 -> a
a

"La \"mamma\" è voce del linguaggio familiare e di tono affettuoso, usata perciò di regola come vocativo, o quando si parla della madre con i familiari o gli amici intimi" -> mamma

mamma

(2+2 == 4) -> equazione
(2+3 < 4) -> disequazione
equazione
disequazione
```

Come abbiamo già visto, quando si scrive il termine dell'oggetto e si esegue il codice (con Invio oppure eseguendo l'intero blocco chunk), viene eseguito un `print` implicito dell'oggetto. Questa operazione viene chiamata "invocazione" oppure chiamata (call) di un oggetto.

Nel caso di valori logici è corretto parlare di "Interrogazione" rispetto ad una proposizione. Le interrogazioni sono concetti utili, per esempio il comando:

```{r}
stringr::str_detect("Roma è la capitale","capitale")
stringr::str_detect("Io vivo a Roma","capitale")

```
interroga se il gramma "capitale" è contenuto nel gramma "Roma è la capitale" e poi nel gramma "Io vivo a Roma".


### Salvare e caricare files

Tutti i termini vengono memorizzati in un file di memoria temporanea che sarà autodistrutto **SE** non viene salvato. Inoltre, tutti i termini sono visualizzabili nella finestra "Environments".

Ci sono diversi modi per salvare questo file di memoria. Il più immediato è salvare l'intero file in formato `.Rdata` cliccando sull'iconcina del floppy disk (sapete cosa sia un floppy disk???) nella finestra Environment.
Un modo alternativo più rapido di "salvare il workspace" è il comando:

```{r}
save.image("NOME_DEL_FILE.RData")
```

Vi accorgerete che nella finestra files è spuntato un file `.RData`.

Questi file `.RData` sono solitamente molto leggeri, ma potranno essere letti (importati) solo da altri computer in cui è installato R.
Per importare / caricare / leggere un file `.RData` salvato, basta cliccare su quel file nella lista dei files.

Facciamo la prova cancellando il workspace e poi ricaricando la copia salvata.

Per cancellare il workspace bisgona premere sul simbolino della scopa in alto rispetto al workspace. Si possono cancellare selettivamente solo certi files, selezionandone la spunta in modalità Grid (Griglia).

Dopo aver introdotto le **strutture dati**, scopriremo che le tabelle, che sono la struttura tipica della Statistica Multivariata, possono essere salvate ed importate in altri formati standard. R ha una grande capacità di leggere (cioé di "importare") tanti formati dati.

## I vettori

I vettori sono **insiemi ordinati** di valori della stessa tipologia.
I vettori sono caratterizzati da un comando un po' insolito, la lettera "c", che abbrevia il verbo "concatenate", ma si può anche usare un comando che richiama la tipologia dell'insieme per forzare tale tipologia.

```{r}
c(1,2,3) -> vettore_numerico

c("Pippo", "Claudio", "Maria") -> amici

vettore_numerico
amici

c(2+2==4,3>5, 3<4) -> Domandina

Domandina

as.integer(Domandina)

c(1,"mamma","zio")
```

### Ordinamento dei vettori

I vettori sono **ordinati**. Ogni valore contenuto in un vettore ha una posizione e si chiama "elemento". Per richiamare un elemento in una data posizione si invoca il vettore seguito dal numero della posizione tra parentesi quadra:

```{r}
amici[2]

amici[2:3]

amici[c(1,3)]
```
La cosa interessante di questo chunk è che è possibile richiamare più di un elemento inserendo un vettore **integer** invece di un singolo numero. Una costruzione intelligente di un **vettore integer** con le posizioni degli elementi da richiamare può eseguire una ricerca mirata in un lungo vettore. In questo caso la formula `2:3` comanda: da 2 a 3.

In questo modo è possibile anche fare assegnazioni non banali.

```{r}
amici[c(1,3)] -> superamici
```


# Liste, data.frame e tibbles (Tabelle)

I vettori si possono combinare in due tipologie di contenitore:

- Le liste: sono un contenitore piuttosto flessibile e con pochissimi requisiti. Sono maggiormente usate negli aspetti più informatici per operazioni di organizzazione interna dei dati. Non saranno approfondite in questo corso.
- Le tabelle: R possiede una struttura base per le tabelle, il `data.frame`. Noi però useremo una struttura più raffinata, la `tibble`, che fa parte del dialetto "Tidyverse".

La costruzione di tabelle deve rispettare:

- Regole di codice informatico, senza le quali R non è capace di organizzare la tabella e restituirà un errore.
- Regole di standard d'uso, che sono rispettate per rendere il lavoro più fluido e veloce.

## REGOLE MECCANICHE PER FORMARE UNA TABELLA

Una tabella incrocia un numero positivo di colonne (variabili) con un certo numero non negativo di righe (osservazioni). L'elemento base della tabella è **LA COLONNA, NON LA RIGA**.

- Ogni colonna vede sé stessa come un vettore e ne rispetta le regole.
- Ogni riga vede sé stessa come una tabella (di una sola riga) e ne rispetta le regole.
- REGOLA IMPORTANTISSIMA: tutte le colonne della tabella devono avere lo stesso numero di elementi, cioé devono essere della stessa lunghezza. Ogni qual volta che si comanda a R qualcosa che viola questa regola, R si rifiuterà di eseguire

---
Le Liste non seguono queste regole, per questo sono più agili per operazioni interni. Un bravo data scientist usa le liste per preparare i dati, ma poi le converte in tabelle alla fine della fase preparatoria.
---

Che succede se nel formare una tabella mi manca una informazione e quindi sospetto che i miei vettori non saranno della stessa lunghezza? In questo caso si usa il simbolo `NA`, che significa "missing value", ovverosia "informaizone mancante".

### I comandi per formare una tabella tibble

Le `tibble` si costruiscono per colonne, separate da virgole.

```{r}

Tabella1 <- tibble(
  Numeri = c(1,2,3),
  Cognomi = c("Rossi","Verdi","Tomaselli")
)

```

Notate bene che siccome `tibble` fa parte del dialetto Tidyverse, qui preferisco usare `=` per assegnare il contenuto dei vettori ai nomi delle colonne.

Ci sono anche molti altri modi di formare una tabella da zero, ma questo è quello basilare.

Due tabelle possono essere unite (bindate) in per righe:

```{r}
rbind(Tabella1,
      tibble(
        Numeri = c(4,NA,6),
        Cognomi = c("Rossi","Verdi","Cantone")
        )
      )
```
O per colonne:

```{r}
cbind(Tabella1,
      tibble(
        Numeri = c(4,NA,6),
        Cognomi = c("Rossi","Verdi","Cantone")
        )
      )
```

Una alternativa forse migliore è semplicemente usare il dialetto Tidyverse. 

```{r}
add_row(Tabella1,
        tibble(
          Numeri = c(4,NA,6),
          Cognomi = c("Rossi","Verdi","Cantone")
          )
        )
```

Ma che succede se ora provo a fare lo stesso per colonne?

```{r eval=FALSE}
add_column(Tabella1,
           tibble(
             Numeri = c(4,NA,6),
             Cognomi = c("Rossi","Verdi","Cantone")
             )
           )
```

Perchè prima non dava errore?

Useremo un nuovo comando che investiga la tipologia di struttura.

```{r}
cbind(Tabella1,
      tibble(
        Numeri = c(4,NA,6),
        Cognomi = c("Rossi","Verdi","Cantone")
        )
      ) %>% class()
```

---
` %>%` è un operatore particolare. Si chiama "Pipe" o "Incanalatore" o "Intubatore" e serve a cambiare la sintassi di R nel dialetto Tydiverse. In questo caso, serve a dichiarare un comando in questa forma: "Bindami queste colonne E POI dimmi la tipologia (class) della struttura risultante".
---

Ebbene, R ha interpretato il comando `cbind` come se dovesse *anche* cambiare la tipologia di tabella da `tibble` a `data.frame`. Questo perché le `tibble` **NON AMMETTONO** due colonne con lo stesso nome, mentre i `data.frame` sì. 


## DOGMA DI TIDYVERSE

Questo è un Dogma che viene usato da ogni programmatore "Tidy":

- Ogni colonna deve rappresentare una variabile differente.
- Ogni riga deve rappresentare una osservazione differente.
- Ogni incrocio di colonna e riga deve assumere un valore *valido* per quella colonna, oppure un *valore mancante*/*missing value* (`NA`). Se invece il valore **non può esistere**, si usa `NaN`.

## Studio sulle "Tabelle ben formate"

Questa è una generica tabella:

```{r}
set.seed(1810)
tibble(Dado_1 = sample(1:6, 30, replace = T),
       Dado_2 = sample(1:6, 30, replace = T))
```

---
In questa tabella il comando `sample()` campiona, ovverosia, estrae a caso dei numeri come se lanciassimo dei dadi.
Il comando `set.seed()` contenente un numero serve a rendere replicabile in maniera identica proprio quel lancio dei dati, che però non può essere conosciuto a priori. Molti filosofi dell'informazione trovano questo argomento molto interessante e parlando correttamente di "pseudo random number generation".
---

Qual è il problema della tabella qui sotto?

```{r}
set.seed(1810)
data.frame(
  Nome.1 = sample(c("Giovanni", "Maria", "Carlo", "Paola"),30, replace = T),
  Dado_1 = sample(1:6, 30, replace = T),
  Nome.2 = sample(c("Giovanni", "Maria", "Carlo", "Paola"),30, replace = T),
  Dado_2 = sample(1:6, 30, replace = T)
       )
```

---

Che problemi abbiamo qui?

```{r}
set.seed(1810)
data.frame(Nome = c("Giorgio", "Michela", "Laura", "Arancione"),
           "Stato Civile" = c("Sposato con Michela", NA, "Nubile", "Sposato"),
           Età = c(34,28,"venti",20)
)
```

# Salvare ed Importare in formato .csv ed Excel

Un formato standard per salvare le tabelle è il formato .csv
Facile da leggere, ma un po' pesantuccio.

Per salvare un csv, il comando è:

```{r}

nome_della_tabella = tibble(Prova = c(1,2))

write.csv(nome_della_tabella,"LaMiaTabella.csv")
```

Per importare (caricare, leggere) un .csv, si può cliccare sul .csv se si trova nella cartella del Progetto. Alternativamente si usa l'interfaccia accessibile da:

Files -> Import Dataset -> From text (readr).

Qui avrete una preview di ciò che state importando e potrete controllare che R sta interpretando correttamente le tipologie delle colonne della tabella (dataset). In basso a destra apparirà il codice per ri-eseguire l'operazione senza usare l'interfaccia.

Il mio consiglio è di copiare quel codice nel vostro documento script o Markdown.

Questa stessa operazione può essere usata per caricare tabelle da Excel. Al posto del pacchetto "readr" useremo il pacchetto "readxl".

```{r}
pacman::p_load(readxl)
Laureati <- read_excel("base_dati_CICCHITELLI_excel/Laureati.xls", 
    col_types = c("numeric", "text", "date", 
        "text", "numeric", "numeric", "date", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric"))
```
Per salvare una tabella come file Excel il comando è:

```{r}
writexl::write_xlsx(nome_della_tabella,"LaMiaTabella.xlsx")
```

---
COMANDO IMPORTANTISSIMO
Per Visualizzare una tabella (o qualunque altro tipo di struttura) si usa il comando `View()`. La V deve essere maiuscola. Le `tibble` sono piuttosto agevoli da visualizzare, mentre le liste lo sono di meno...

Quando si da un `print` (implicito o esplicito) di una tibble, di solito si visualizzano le prime diece osservazioni e le prime colonne.
---

### Chiamare elementi delle tabelle

Per chiamare una variable incolonnata, si chiama il numero della colonna con `tabella[numero_colonna]` oppure si chiama il nome della colonna con `tabella$nome_colonna`.

```{r}
tibble(Nomi = c("Pippo","Paperino"),
       Età = c(30,32)
       ) -> Tabella1

Tabella1$Nomi
Tabella1[2]

#Per chiamare una riga si mette una virgola dopo il numero tra parentesi quadre.

Tabella1[2,]
```
Di solito però le righe sono filtrate con strumenti diversi del dialetto tidyverse.

# Importare database dal web

Tra le funzioni più entuasiamanti di R c'è la possibilità di condividere database (cioé: insiemi di tabelle) senza mai veramente uscire da R Studio. Di fatto, tutta la gestione della trasmissione dati viene gestita da R Studio.

Come esempio, studieremo il pacchetto `owidR`. Che è una API, cioé un software di interfaccia guidata, con il sito [Our World in Data](https://ourworldindata.org/).

```{r eval=FALSE}
pacman::p_load(owidR)

owidR::owid_covid() -> Covid
```

```{r}
owid_search("education") %>% View()
```

```{r}
owid("pupil-teacher-ratio-for-primary-education-by-country") -> Education

Education %>% View()
```

```{r}
Education %>% filter(entity == "Italy") %>% View()
```

Consiglio personale per la vostra tesi di laurea: scegliete una parola chiave e guardate come questa si sviluppa nei database di OWID. A quel punto non fidatevi ciecamente dei database di OWID, ma cercate di capire quali sono le variabili che ricorrono come legate a quella parola chiave. Questo funge da una sorta di "studio di letteratura" che vi permette di capire, storicamente, con che tipo di studi è stata approcciato il tema che vi interessa.


```{r}
owid_search("leisure") %>% View()
```
